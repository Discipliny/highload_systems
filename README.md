[Журнал](https://docs.google.com/spreadsheets/d/1laJ4IDAB71iIuJbBFzVwoLQN48SbsEBBWarDtV-nm8s/)

Цель курса - получить практические полезные навыки разработки на современном JVM стеке в написании серверов.

В течение семестра выполняется групповой проект, который поэтапно модифицируется.

# Лабораторная работа №1

Написать монолит с использованием Spring Boot.

Разрешены языки: Java, Kotlin.

Разрешены системы сборки: Maven, Gradle, Bazel.

Использовать стабильные версии фреймворков, библиотек, языков. При написании придерживаться языковым конвенциям [Java](https://www.oracle.com/java/technologies/javase/codeconventions-contents.html), [Kotlin](https://kotlinlang.org/docs/coding-conventions.html). 

Следовать принципам разработки ПО, таким как SOLID, DRY, KISS и др.

При разработке использовать git feature branching strategy. При выборе имен для коммитов необходимо придерживаться [conventional commits](https://www.conventionalcommits.org/en/v1.0.0/).

Код должен быть покрыт модульными и интеграционными тестами с помощью testcontainers и junit-jupiter-api, берём лучше [отсюда](https://se.ifmo.ru/courses/testing), ещё можно зайти [сюда](https://docs.google.com/presentation/d/1tcPapWwmrAb0Ju88OILOAiOShcTVbHrvw9ZFii2bLpI/edit?usp=sharing). Минимальный общий процент покрытия кода тестами 70%.

## Основные требования:

 - Основные сущности должны иметь осмысленный CRUD интерфейс с использованием REST API.
 - Использовать правильные http статусы для ответов.
 - Для запросов к БД использовать Spring Data JPA/JDBC.
 - Должна быть реализована валидация полей на уровне контроллера и на уровне Entity.
 - Структура БД должна создаваться через Liquibase/Flyway миграции.
 - Для проверки бизнес-логики должны быть написаны интеграционные тесты с использованием testcontainers и junit-jupiter-api.
 - Использовать переменные среды для конфигурации приложения. При развертывании их можно задавать через поле enviroments: в docker-compose.yml.
 - Приложение должно собираться с использованием docker и запускаться через docker-compose.
 - Использовать любую реляционную/нереляционную БД (зависит от информационной системы), запущенную через docker.
 - Каждый findAll должен иметь пагинацию. Нельзя отдавать больше 50 записей за один запрос.
 - Должен быть минимум один запрос, который вернет findAll в виде бесконечной прокрутки без указания общего количества записей.
 - Должен быть минимум один запрос, который вернет findAll с пагинацией и с указанием общего количества записей в http хедере.
 - На сложных запросах должны использоваться транзакции. Должно быть не меньше двух подобных запросов. Обосновать почему там нужны транзакции.
 - Разделять модели Entity и Dto.
 - Приложение должно иметь чистый код и архитектуру с разделением по сервисам, репозиториям, контроллерам, моделям и т.д.
 - Все enums в БД должны сериализоваться как строки.
 - Ошибки (Exception) из контроллеров нужно хендлить и отдавать человеко читаемую ошибку в теле ответа.
 - Продумать и согласовать архитектуру БД с преподавателем.
 - Должны быть реализованы связи между сущностями каждого типа: Many to Many, One to Many/Many to One, Many to Many с дополнительным полем.

# Лабораторная работа №2

Декомпозировать на микросервисы разработанную систему из лабораторной работы 1 и добавить авторизацию.

 - Микросервисы должны регистрироваться в [Eureka](https://spring.io/projects/spring-cloud-netflix).
 - Микросервисы должны подтягивать конфигурацию из [Config-Server](https://spring.io/projects/spring-cloud-config).
 - Микросервисы должны быть доступны через [Spring Gateway](https://spring.io/projects/spring-cloud-gateway).
 - Для взаимодействия между микросервисами использовать Feign Client.
 - Внедрить [Circuit Breaker](https://cloud.spring.io/spring-cloud-netflix/multi/multi__circuit_breaker_hystrix_clients.html).
 - Разрешить проблему с авторизацией между микросервисами и не забыть сделать тесты и отредактировать тесты из 1 лабораторной работы.
 - Минимум один микросервис должен быть написан с использованием Reactor и R2DBC.
 - Минимум один микросервис должен быть написан с использованием Reactor и Spring Data JPA/JDBC.

## Требования к авторизации:

- Для авторизации использовать spring-security в комбинации с JWT токеном в хедере Authorization.
- Реализовать ролевую модель.
- Должны быть методы, логика которых меняется в зависимости от текущего пользователя. Пример: Повар не может загружать товары на склад, а логист не может принимать заказы у пользователей.
- Не отдавать пароль в запросе, где участвуют модели пользователя.
- Все пароли должны храниться в хэшированном виде.
- Пользователей могут создавать только супервайзеры.


# Лабораторная работа №3

 - Добавить микросервис по работе с уведомлениями с помощью Kafka (минимум 3 брокера, сделать несколько топиков, настроить репликацию), если нет возможности сделать уведомления в каком-то текущем микросервисе.
 - Добавить микросервис по работе для загрузки и получения файлов.
 - В рамках реализации этих микросервисов использовать вебсокеты и очереди сообщений.
 - Добавить интерактивную документацию с помощью OpenApi 3.
 - Развернуть Swagger, в котором будет храниться документация API системы (всех микросервисов).
 - Развернуть CI с использованием Jenkins/GitHub/GitLab/TeamCity, всё должно быть поднято на серверах, а не локально.


# Лабораторная работа №4**

- Внедрить в проект Kubernetes.
- Добавить распределённый кэш с помощью Hazelcast.
- Обмен сообщениями должен происходить по Kafka (минимум 3 брокеры, сделать несколько топиков, настроить репликацию).
- Реализовать паттерн Saga.
- Интегрировать в проект SonarQube с помощью CI/CD.
- Все микросервисы должны соответствовать принципам Clean Architecture.

** опционально за экзамен